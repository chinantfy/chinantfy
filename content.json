{"meta":{"title":"Chinantfy'Blogs","subtitle":"倚楼听风雨，淡看江湖路","description":null,"author":"chinantfy","url":"https://chinantfy.gitee.io","root":"/"},"pages":[{"title":"分类","date":"2019-11-12T16:04:08.000Z","updated":"2020-02-24T15:36:17.904Z","comments":true,"path":"categories/index.html","permalink":"https://chinantfy.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"archives 归档","date":"2019-11-12T16:05:31.000Z","updated":"2020-02-24T15:36:17.904Z","comments":true,"path":"archives/index.html","permalink":"https://chinantfy.gitee.io/archives/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-12T16:05:40.000Z","updated":"2020-02-24T15:36:17.904Z","comments":true,"path":"tags/index.html","permalink":"https://chinantfy.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git常用命令","slug":"10.git常用命令","date":"2020-02-24T15:55:30.000Z","updated":"2020-03-08T10:44:39.720Z","comments":true,"path":"2020/02/24/10.git常用命令/","link":"","permalink":"https://chinantfy.gitee.io/2020/02/24/10.git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"初始化目录Code1git init 提交文件到缓存区Code1git add readme.txt 提交文件到仓库Code1git commit -m &quot;wrote a readme file&quot; #-m后面是对于本次提交的注释说明 可以多次add不同文件，一次提交多个文件Code123git add file1.txtgit add file2.txt file3.txtgit commit -m &quot;add 3 files.&quot; 查看当前仓库状态Code1git status 查看文件上次提交的差异Code1git diff readme.txt 查看提交历史记录Code1git log 简版显示提交历史记录Code1git log --pretty=oneline 回退上一个版本Code1git reset --hard HEAD^ 回退指定版本Code1git reset --hard 1094a 查看所有命令历史记录(git log在回退版本后会看不到回退前版本的记录，reflog可以看所有记录)Code1git reflog 查看工作区和版本库里面最新版本的区别(当前文件夹为工作区，add后是暂存区)Code1git diff HEAD -- readme.txt 将工作区文件恢复版本库版本Code1git checkout -- readme.txt 会有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。将暂存区文件版本丢弃，放回工作区Code1git reset HEAD readme.txt 从版本库删除文件Code12git rm test.txtgit commit -m &quot;remove test.txt&quot; 创建分支并切换到分支Code123456git checkout -b dev或git branch devgit checkout dev或git switch -c dev 查看当前分支，列出所有分支，当前分支前面会标一个*号Code1git branch 切换回主分支Code123git checkout master或git switch master 将指定分支合并到当前分支Code12快速合并git merge dev Code12普通模式合并分支，可以通过log查看分支信息git merge --no-ff -m &quot;merge with no-ff&quot; dev 查看合并冲突Code1git status 合并冲突时要手动修改文件并提交 查看分支合并情况Code1git log --graph --pretty=oneline --abbrev-commit 删除分支Code1git branch -d dev 本地仓库关联码云Code1git remote add origin git@gitee.com:chinantfy/learngit.git 查看远程库信息Code1git remote -v 删除远程库Code1git remote rm origin 推送到gitee首次推送时加-u参数Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 Code12git push -u origin mastergit push github master 本地仓库关联githubCode1git remote add github git@github.com:chinantfy/learngit.git 暂时封存现在分支状态，在不提交的情况下就可以切换分支（默认有文件未提交时无法切换分支）Code1git stash 切换回封存的分支后查看封存状态Code1git stash list 恢复状态恢复状态并删除stashCode1git stash pop 恢复状态，删除stashCode12git stash apply stash@&#123;0&#125;git stash drop stash@&#123;0&#125; 复制一个特定的提交到当前分支Code1git cherry-pick 4c805e2","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://chinantfy.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git常用命令","slug":"git常用命令","permalink":"https://chinantfy.gitee.io/tags/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]},{"title":"Python基础命令","slug":"09.python基础命令","date":"2020-01-11T15:28:43.000Z","updated":"2020-03-14T01:54:36.321Z","comments":true,"path":"2020/01/11/09.python基础命令/","link":"","permalink":"https://chinantfy.gitee.io/2020/01/11/09.python%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","excerpt":"","text":"本文参考： Python-100-Days 廖雪峰Python 感谢两位大神的无私奉献 注释 单行注释 - 以#和空格开头的部分 多行注释 - 三个引号开头，三个引号结尾(单双引都可以) 变量和类型 整型 int 浮点型（小数） float 字符串型 str 布尔型 bool 只有两个值 True、False 复数型 complex 查看变量类型： Code1234q = 1234type(q)int 变量命名 硬性规则： 变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。 大小写敏感（大写的a和小写的A是两个不同的变量）。 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： 用小写字母拼写，多个单词用下划线连接。 受保护的实例属性用单个下划线开头（后面会讲到）。 私有的实例属性用两个下划线开头（后面会讲到）。 当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到见名知意也是非常重要的。 变量的使用下面通过几个例子来说明变量的类型和变量使用。 python12345678910111213\"\"\"使用变量保存数据并进行算术运算\"\"\"a = 321b = 123print(a + b) #444print(a - b) #198print(a * b) #39483print(a / b) #2.6097560975609757print(a // b) #2print(a % b) #75print(a ** b) #乘方 python1234567891011121314\"\"\"使用type()检查变量的类型\"\"\"a = 100b = 12.345c = 1 + 5jd = 'hello, world'e = Trueprint(type(a)) # &lt;class 'int'&gt;print(type(b)) # &lt;class 'float'&gt;print(type(c)) # &lt;class 'complex'&gt;print(type(d)) # &lt;class 'str'&gt;print(type(e)) # &lt;class 'bool'&gt; 可以使用Python中内置的函数对变量类型进行转换。 int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 下面的代码通过键盘输入两个整数来实现对两个整数的算术运算。 python12345678910111213141516\"\"\"使用input()函数获取键盘输入(字符串)使用int()函数将输入的字符串转换成整数使用print()函数输出带占位符的字符串\"\"\"a = int(input('a = '))b = int(input('b = '))print('%d + %d = %d' % (a, b, a + b))print('%d - %d = %d' % (a, b, a - b))print('%d * %d = %d' % (a, b, a * b))print('%d / %d = %f' % (a, b, a / b))print('%d // %d = %d' % (a, b, a // b))print('%d %% %d = %d' % (a, b, a % b))print('%d ** %d = %d' % (a, b, a ** b)) 说明：上面的print函数中输出的字符串使用了占位符语法，其中%d是整数的占位符，%f是小数的占位符，%%表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成%%），字符串之后的%后面跟的变量值会替换掉占位符然后输出到终端中，运行上面的程序，看看程序执行结果就明白啦。 运算符 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ | 按位异或，按位或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ` =^=&gt;&gt;=&lt;&lt;=` 说明： 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。 python123456789\"\"\"赋值运算符和复合赋值运算符\"\"\"a = 10b = 3a += b # 相当于：a = a + ba *= a + 2 # 相当于：a = a * (a + 2)print(a) # 13 * 15 = 195 下面的例子演示了比较运算符（关系运算符）、逻辑运算符和身份运算符的使用。 python12345678910111213141516171819\"\"\"比较、逻辑和算身份运算符的使用\"\"\"flag0 = 1 == 1flag1 = 3 &gt; 2flag2 = 2 &lt; 1flag3 = flag1 and flag2flag4 = flag1 or flag2flag5 = not (1 != 2)print('flag0 =', flag0) # flag0 = Trueprint('flag1 =', flag1) # flag1 = Trueprint('flag2 =', flag2) # flag2 = Falseprint('flag3 =', flag3) # flag3 = Falseprint('flag4 =', flag4) # flag4 = Trueprint('flag5 =', flag5) # flag5 = Falseprint(flag1 is True) # Trueprint(flag2 is not False) # False 字符串和常用数据结构字符串把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。 python123456789101112131415161718s1 = 'hello, world!'s2 = \"hello, world!\"# 以三个双引号或单引号开头的字符串可以折行s3 = \"\"\"hello, world!\"\"\"print(s1, s2, s3, end='') # end''表示结尾不换行print(s1, end='')print(s2) # hello, world!hello, world!print(s1)print(s2) #hello, world!#hello, world! 字符串中使用\\（反斜杠）来表示转义，也就是说\\后面的字符不再是它原来的意义，例如：\\n不是代表反斜杠和字符n，而是表示换行；而\\t也不是代表反斜杠和字符t，而是表示制表符。所以如果想在字符串中表示&#39;要写成\\&#39;，同理想表示\\要写成\\\\。 在\\后面还可以跟一个八进制或者十六进制数来表示字符，例如\\141和\\x61都代表小写字母a，前者是八进制的表示法，后者是十六进制的表示法。也可以在\\后面跟Unicode字符编码来表示字符，例如\\u9a86\\u660a代表的是中文“骆昊”。 如果不希望字符串中的\\表示转义，我们可以通过在字符串的最前面加上字母r来加以说明 python1234s1 = r'\\'hello, world!\\''s2 = r'\\n\\\\hello, world!\\\\\\n'print(s1, s2, end='')#输出： \\'hello, world!\\' \\n\\\\hello, world!\\\\\\n 字符串与字节互转 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： Code12345678&gt;&gt;&gt; ord(&apos;A&apos;)65&gt;&gt;&gt; ord(&apos;中&apos;)20013&gt;&gt;&gt; chr(66)&apos;B&apos;&gt;&gt;&gt; chr(25991)&apos;文&apos; 字符串转字节 Code123456&gt;&gt;&gt; &apos;ABC&apos;.encode(&apos;ascii&apos;)b&apos;ABC&apos;&gt;&gt;&gt; &apos;中文&apos;.encode(&apos;utf-8&apos;)b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos;&gt;&gt;&gt; b&apos;\\xe4\\xb8\\xad\\xff&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;) #如果bytes中只有一小部分无效的字节，可以传入errors=&apos;ignore&apos;忽略错误的字节&apos;中&apos; 要计算str包含多少个字符，可以用len()函数： Code1234&gt;&gt;&gt; len(&apos;ABC&apos;)3&gt;&gt;&gt; len(&apos;中文&apos;)2 len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数： Code123456&gt;&gt;&gt; len(b&apos;ABC&apos;)3&gt;&gt;&gt; len(b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos;)6&gt;&gt;&gt; len(&apos;中文&apos;.encode(&apos;utf-8&apos;))6 1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节. Python为字符串类型提供了非常丰富的运算符，我们可以使用+运算符来实现字符串的拼接，可以使用*运算符来重复一个字符串的内容，可以使用in和not in来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用[]和[:]运算符从字符串取出某个字符或某些字符（切片运算），代码如下所示。 字符串中位置由0位开始 python1234567891011121314151617s1 = 'hello ' * 3print(s1) # hello hello hello s2 = 'world's1 += s2print(s1) # hello hello hello worldprint('ll' in s1) # Trueprint('good' in s1) # Falsestr2 = 'abc123456'# 从字符串中取出指定位置的字符(下标运算)print(str2[2]) # c# 字符串切片(从指定的开始索引到指定的结束索引)print(str2[2:5]) # c12print(str2[2:]) # c123456print(str2[2::2]) # c246print(str2[::2]) # ac246print(str2[::-1]) # 654321cbaprint(str2[-3:-1]) # 45 切片实际结束的位置是在指定结束索引之前，如print(str2[2:5]) 是指索引2，3，4对应的字符并不包含5对应的字符 常用字符串处理python12345678910111213141516171819202122232425262728293031323334353637str1 = 'hello, world!'str11 = '武汉加油'# 通过内置函数len计算字符串的长度，非中文是指字符个数，一个汉字是1个长度print(len(str1)) # 13print(len(str11)) # 4# 获得字符串首字母大写的拷贝print(str1.capitalize()) # Hello, world!# 获得字符串每个单词首字母大写的拷贝print(str1.title()) # Hello, World!# 获得字符串变大写后的拷贝print(str1.upper()) # HELLO, WORLD!# 从字符串中查找子串所在位置print(str1.find('or')) # 8print(str1.find('shit')) # 找不到时返回-1# 与find类似但找不到子串时会引发异常# print(str1.index('or'))# print(str1.index('shit'))# 检查字符串是否以指定的字符串开头print(str1.startswith('He')) # Falseprint(str1.startswith('hel')) # True# 检查字符串是否以指定的字符串结尾print(str1.endswith('!')) # True# 将字符串以指定的宽度居中并在两侧填充指定的字符print(str1.center(50, '*'))# 将字符串以指定的宽度靠右放置左侧填充指定的字符print(str1.rjust(50, ' '))str2 = 'abc123456'# 检查字符串是否由数字构成print(str2.isdigit()) # False# 检查字符串是否以字母构成print(str2.isalpha()) # False# 检查字符串是否以数字和字母构成print(str2.isalnum()) # Truestr3 = ' jackfrued@126.com 'print(str3)# 获得字符串修剪左右两侧空格之后的拷贝print(str3.strip()) #相当于sql中的trim，去除两端空格 格式化输出python12345678a, b = 5, 10print('%d * %d = %d' % (a, b, a * b))a, b = 5, 10print('&#123;0&#125; * &#123;1&#125; = &#123;2&#125;'.format(a, b, a * b))a, b = 5, 10print(f'&#123;a&#125; * &#123;b&#125; = &#123;a * b&#125;') %占位符常用列表: s，获取传入对象的str方法的返回值，并将其格式化到指定位置 r，获取传入对象的repr方法的返回值，并将其格式化到指定位置 c，整数：将数字转换成其unicode对应的值，10进制范围为 0 &lt;= i &lt;= 1114111（py27则只支持0-255）；字符：将字符添加到指定位置 o，将整数转换成 八 进制表示，并将其格式化到指定位置 x，将整数转换成十六进制表示，并将其格式化到指定位置 d，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置 e，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e） E，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E） f， 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位） F，同上 g，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；） G，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；） %，当字符串中存在格式化标志时，需要用 %%表示一个百分号 列表数值类型是标量类型，也就是说这种类型的对象没有可以访问的内部结构；而字符串类型是一种结构化的、非标量类型，所以才会有一系列的属性和方法。接下来我们要介绍的列表（list），也是一种结构化的、非标量类型，它是值的有序序列，每个值都可以通过索引进行标识，定义列表可以将列表的元素放在[]中，多个元素用,进行分隔，可以使用for循环对列表元素进行遍历，也可以使用[]或[:]运算符取出列表中的一个或多个元素。 查看或遍历列表python12345678910111213141516171819202122232425262728293031list1 = [1, 3, 5, 7, 100]print(list1) # [1, 3, 5, 7, 100]# 乘号表示列表元素的重复list2 = ['hello'] * 3print(list2) # ['hello', 'hello', 'hello']# 计算列表长度(元素个数)print(len(list1)) # 5# 下标(索引)运算print(list1[0]) # 1print(list1[4]) # 100# print(list1[5]) # IndexError: list index out of rangeprint(list1[-1]) # 100print(list1[-3]) # 5list1[2] = 300 #改变索引2对应的值print(list1) # [1, 3, 300, 7, 100]# 通过循环用下标遍历列表元素for index in range(len(list1)): print(list1[index])# 通过for循环遍历列表元素for elem in list1: print(elem)# 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值for index, elem in enumerate(list1): print(index, elem)'''0 11 32 3003 74 100''' 如何向列表中添加元素以及如何从列表中移除元素。python12345678910111213141516171819202122list1 = [1, 3, 5, 7, 100]# 添加元素list1.append(200) #[1, 3, 5, 7, 100, 200]在原来列表末尾增加list1.insert(1, 400) #[1, 400, 3, 5, 7, 100, 200]在指定索引插入，原元素依次后移# 合并两个列表# list1.extend([1000, 2000])list1 += [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]print(len(list1)) # 9# 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1: list1.remove(3)if 1234 in list1: list1.remove(1234)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]# 从指定的位置删除元素list1.pop(0)list1.pop(len(list1) - 1)print(list1) # [400, 5, 7, 100, 200, 1000]# 清空列表元素list1.clear()print(list1) # [] 列表切片、复制python12345678910111213fruits = ['grape', 'apple', 'strawberry', 'waxberry']fruits += ['pitaya', 'pear', 'mango']# 列表切片fruits2 = fruits[1:4]print(fruits2) # apple strawberry waxberry# 可以通过完整切片操作来复制列表fruits3 = fruits[:] #也可以直接写fruits3 = fruitsprint(fruits3) # ['grape', 'apple', 'strawberry', 'waxberry', 'pitaya', 'pear', 'mango']fruits4 = fruits[-3:-1]print(fruits4) # ['pitaya', 'pear']# 可以通过反向切片操作来获得倒转后的列表的拷贝fruits5 = fruits[::-1]print(fruits5) # ['mango', 'pear', 'pitaya', 'waxberry', 'strawberry', 'apple', 'grape'] 列表的排序python1234567891011121314list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry']list2 = sorted(list1)# sorted函数返回列表排序后的拷贝不会修改传入的列表# 函数的设计就应该像sorted函数一样尽可能不产生副作用list3 = sorted(list1, reverse=True) #reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）# 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序list4 = sorted(list1, key=len)print(list1) #['orange', 'apple', 'zoo', 'internationalization', 'blueberry']print(list2) #['apple', 'blueberry', 'internationalization', 'orange', 'zoo']print(list3) #['zoo', 'orange', 'internationalization', 'blueberry', 'apple']print(list4) #['zoo', 'apple', 'orange', 'blueberry', 'internationalization']# 给列表对象发出排序消息直接在列表对象上进行排序，sort会修改原列表顺序list1.sort(reverse=True)print(list1) #['zoo', 'orange', 'internationalization', 'blueberry', 'apple'] 元组 Python中的元组与列表类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，不同之处在于元组的元素不能修改 元组转换列表 person = list(t) 列表转换元组fruits_tuple = tuple(fruits_list) Python12345678910111213141516171819202122232425# 定义元组t = ('骆昊', 38, True, '四川成都')print(t)# 获取元组中的元素print(t[0])print(t[3])# 遍历元组中的值for member in t: print(member)# 重新给元组赋值# t[0] = '王大锤' # TypeError# 变量t重新引用了新的元组原来的元组将被垃圾回收t = ('王大锤', 20, True, '云南昆明')print(t)# 将元组转换成列表person = list(t)print(person)# 列表是可以修改它的元素的person[0] = '李小龙'person[1] = 25print(person)# 将列表转换成元组fruits_list = ['apple', 'banana', 'orange']fruits_tuple = tuple(fruits_list)print(fruits_tuple) 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。 元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间 . 集合 可以按照下面代码所示的方式来创建和使用集合。 python1234567891011# 创建集合的字面量语法set1 = &#123;1, 2, 3, 3, 3, 2&#125;print(set1)print('Length =', len(set1))# 创建集合的构造器语法(面向对象部分会进行详细讲解)set2 = set(range(1, 10))set3 = set((1, 2, 3, 3, 2, 1))print(set2, set3)# 创建集合的推导式语法(推导式也可以用于推导集合)set4 = &#123;num for num in range(1, 100) if num % 3 == 0 or num % 5 == 0&#125;print(set4) 向集合添加元素和从集合删除元素。 python123456789set1.add(4)set1.add(5)set2.update([11, 12]) #添加11,12,也可以用来合并集合set2.discard(5) #如果是其成员就删除,不是就什么也不做if 4 in set2: set2.remove(4)print(set1, set2)print(set3.pop())print(set3) 集合的成员、交集、并集、差集等运算。 python123456789101112131415161718# 集合的交集、并集、差集、对称差运算print(set1 &amp; set2)# print(set1.intersection(set2))print(set1 | set2)# print(set1.union(set2))print(set1 - set2)# print(set1.difference(set2))print(set1 ^ set2)# print(set1.symmetric_difference(set2))# 判断子集和超集print(set2 &lt;= set1)# print(set2.issubset(set1))print(set3 &lt;= set1)# print(set3.issubset(set1))print(set1 &gt;= set2)# print(set1.issuperset(set2))print(set1 &gt;= set3)# print(set1.issuperset(set3)) 说明： Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如&amp;运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。 字典字典是另一种可变容器模型，Python中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。 python123456789101112131415161718192021222324252627282930313233# 创建字典的字面量语法scores = &#123;'骆昊': 95, '白元芳': 78, '狄仁杰': 82&#125;print(scores)# 创建字典的构造器语法items1 = dict(one=1, two=2, three=3, four=4)# 通过zip函数将两个序列压成字典items2 = dict(zip(['a', 'b', 'c'], '123'))# 创建字典的推导式语法items3 = &#123;num: num ** 2 for num in range(1, 10)&#125;print(items1, items2, items3)# 通过键可以获取字典中对应的值print(scores['骆昊'])print(scores['狄仁杰'])# 对字典中所有键值对进行遍历for key in scores: print(f'&#123;key&#125;: &#123;scores[key]&#125;')# 更新字典中的元素scores['白元芳'] = 65scores['诸葛王朗'] = 71scores.update(冷面=67, 方启鹤=85)print(scores)if '武则天' in scores: print(scores['武则天'])print(scores.get('武则天'))# get方法也是通过键获取对应的值但是可以设置默认值print(scores.get('武则天', 60))# 删除字典中的元素print(scores.popitem()) #删除最后一个元素print(scores.popitem())print(scores.pop('骆昊', 100)) #删除指定元素# 清空字典scores.clear()print(scores) 练习练习1：在屏幕上显示跑马灯文字。参考答案： python1234567891011121314151617import osimport timedef main(): content = '北京欢迎你为你开天辟地…………' while True: # 清理屏幕上的输出 os.system('cls') # os.system('clear') print(content) # 休眠200毫秒 time.sleep(0.2) content = content[1:] + content[0]if __name__ == '__main__': main() 练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。参考答案： python123456789101112131415161718import randomdef generate_code(code_len=4): \"\"\" 生成指定长度的验证码 :param code_len: 验证码的长度(默认4个字符) :return: 由大小写英文字母和数字构成的随机验证码 \"\"\" all_chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' last_pos = len(all_chars) - 1 code = '' for _ in range(code_len): index = random.randint(0, last_pos) code += all_chars[index] return code 练习3：设计一个函数返回给定文件名的后缀名。参考答案： python1234567891011121314def get_suffix(filename, has_dot=False): \"\"\" 获取文件名的后缀名 :param filename: 文件名 :param has_dot: 返回的后缀名是否需要带点 :return: 文件的后缀名 \"\"\" pos = filename.rfind('.') if 0 &lt; pos &lt; len(filename) - 1: index = pos if has_dot else pos + 1 return filename[index:] else: return '' 练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。参考答案： python123456789def max2(x): m1, m2 = (x[0], x[1]) if x[0] &gt; x[1] else (x[1], x[0]) for index in range(2, len(x)): if x[index] &gt; m1: m2 = m1 m1 = x[index] elif x[index] &gt; m2: m2 = x[index] return m1, m2 练习5：计算指定的年月日是这一年的第几天。参考答案： python1234567891011121314151617181920212223242526272829303132333435363738def is_leap_year(year): \"\"\" 判断指定的年份是不是闰年 :param year: 年份 :return: 闰年返回True平年返回False \"\"\" return year % 4 == 0 and year % 100 != 0 or year % 400 == 0def which_day(year, month, date): \"\"\" 计算传入的日期是这一年的第几天 :param year: 年 :param month: 月 :param date: 日 :return: 第几天 \"\"\" days_of_month = [ [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] ][is_leap_year(year)] total = 0 for index in range(month - 1): total += days_of_month[index] return total + datedef main(): print(which_day(1980, 11, 28)) print(which_day(1981, 12, 31)) print(which_day(2018, 1, 1)) print(which_day(2016, 3, 1))if __name__ == '__main__': main() 练习6：打印杨辉三角。参考答案： python12345678910111213141516def main(): num = int(input('Number of rows: ')) yh = [[]] * num for row in range(len(yh)): yh[row] = [None] * (row + 1) for col in range(len(yh[row])): if col == 0 or col == row: yh[row][col] = 1 else: yh[row][col] = yh[row - 1][col] + yh[row - 1][col - 1] print(yh[row][col], end='\\t') print()if __name__ == '__main__': main() 综合案例案例1：双色球选号。python12345678910111213141516171819202122232425262728293031323334from random import randrange, randint, sampledef display(balls): \"\"\" 输出列表中的双色球号码 \"\"\" for index, ball in enumerate(balls): if index == len(balls) - 1: print('|', end=' ') print('%02d' % ball, end=' ') print()def random_select(): \"\"\" 随机选择一组号码 \"\"\" red_balls = [x for x in range(1, 34)] selected_balls = [] selected_balls = sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_ballsdef main(): n = int(input('机选几注: ')) for _ in range(n): display(random_select())if __name__ == '__main__': main() 说明： 上面使用random模块的sample函数来实现从列表中选择不重复的n个元素。 综合案例2：约瑟夫环问题。python123456789101112131415161718192021222324\"\"\"《幸运的基督徒》有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。\"\"\"def main(): persons = [True] * 30 counter, index, number = 0, 0, 0 while counter &lt; 15: if persons[index]: number += 1 if number == 9: persons[index] = False counter += 1 number = 0 index += 1 index %= 30 for person in persons: print('基' if person else '非', end='')if __name__ == '__main__': main() 综合案例3：井字棋游戏。python123456789101112131415161718192021222324252627282930313233343536373839404142import osdef print_board(board): print(board['TL'] + '|' + board['TM'] + '|' + board['TR']) print('-+-+-') print(board['ML'] + '|' + board['MM'] + '|' + board['MR']) print('-+-+-') print(board['BL'] + '|' + board['BM'] + '|' + board['BR'])def main(): init_board = &#123; 'TL': ' ', 'TM': ' ', 'TR': ' ', 'ML': ' ', 'MM': ' ', 'MR': ' ', 'BL': ' ', 'BM': ' ', 'BR': ' ' &#125; begin = True while begin: curr_board = init_board.copy() begin = False turn = 'x' counter = 0 os.system('clear') print_board(curr_board) while counter &lt; 9: move = input('轮到%s走棋, 请输入位置: ' % turn) if curr_board[move] == ' ': counter += 1 curr_board[move] = turn if turn == 'x': turn = 'o' else: turn = 'x' os.system('clear') print_board(curr_board) choice = input('再玩一局?(yes|no)') begin = choice == 'yes'if __name__ == '__main__': main() 说明： 最后这个案例来自《Python编程快速上手:让繁琐工作自动化》一书（这本书对有编程基础想迅速使用Python将日常工作自动化的人来说还是不错的选择），对代码做了一点点的调整。 分支结构python1234567891011121314151617\"\"\"百分制成绩转换为等级制成绩\"\"\"score = float(input('请输入成绩: '))if score &gt;= 90: grade = 'A'elif score &gt;= 80: grade = 'B'elif score &gt;= 70: grade = 'C'elif score &gt;= 60: grade = 'D'else: grade = 'E'print('对应的等级是:', grade) 例：海伦公式 python123456789101112131415\"\"\"判断输入的边长能否构成三角形，如果能则计算出三角形的周长和面积\"\"\"a = float(input('a = '))b = float(input('b = '))c = float(input('c = '))if a + b &gt; c and a + c &gt; b and b + c &gt; a: print('周长: %f' % (a + b + c)) p = (a + b + c) / 2 area = (p * (p - a) * (p - b) * (p - c)) ** 0.5 print('面积: %f' % (area))else: print('不能构成三角形') 循环结构for-in循环python123456789\"\"\"用for循环实现1~100求和\"\"\"sum = 0for x in range(101): sum += xprint(sum) range(101)可以产生一个0到100的整数序列。 range(1, 100)可以产生一个1到99的整数序列。 range(1, 100, 2)可以产生一个1到99的奇数序列，其中2是步长，即数值序列的增量。 while循环如果要构造不知道具体循环次数的循环结构，我们推荐使用while循环。while循环通过一个能够产生或转换出bool值的表达式来控制循环，表达式的值为True循环继续，表达式的值为False循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用while循环。 python123456789101112131415161718192021222324\"\"\"猜数字游戏计算机出一个1~100之间的随机数由人来猜计算机根据人猜的数字分别给出提示大一点/小一点/猜对了\"\"\"import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input('请输入: ')) if number &lt; answer: print('大一点') elif number &gt; answer: print('小一点') else: print('恭喜你猜对了!') breakprint('你总共猜了%d次' % counter)if counter &gt; 7: print('你的智商余额明显不足') 上面的代码中使用了break关键字来提前终止循环，需要注意的是break只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了break之外，还有另一个关键字是continue，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。 练习 Code12345*************** Code12345 * ** *** ********* Code12345 * *** ***** **************** 答案1： python12345678910111213141516row = int(input('请输入行数: ')) + 1for i in range(1, row): q = '*' print(i * q) for i in range(1, row + 1): q = '*' print(' ' * (row - i), end='') print(i * q) for i in range(1, row + 1): q = '*' print(' ' * (row - i), end='') print((2*i - 1) * q) 答案2： python123456789101112131415161718192021row = int(input('请输入行数: '))for i in range(row): for _ in range(i + 1): print('*', end='') print()for i in range(row): for j in range(row): if j &lt; row - i - 1: print(' ', end='') else: print('*', end='') print()for i in range(row): for _ in range(row - i - 1): print(' ', end='') for _ in range(2 * i + 1): print('*', end='') print() 水仙花数python123456for i in range(100, 1000): a = i // 100 # 百分位 b = i % 100 // 10 # 十分位 c = i % 10 # 个位 if a**3 + b**3 + c**3 == i: print(i) python12345678910\"\"\"正整数的反转\"\"\"num = int(input('num = '))reversed_num = 0while num &gt; 0: reversed_num = reversed_num * 10 + num % 10 num //= 10print(reversed_num) python123456789\"\"\"《百钱百鸡》问题\"\"\"for x in range(0, 20): for y in range(0, 33): z = 100 - x - y if 5 * x + 3 * y + z / 3 == 100: print('公鸡: %d只, 母鸡: %d只, 小鸡: %d只' % (x, y, z)) 斐波那契数列python12345a = 0b = 1for _ in range(20): a, b = b, a + b print(a, end=' ') 100以内素数python1234567for i in range(2, 100): q = True for y in range(2, i): if i % y == 0: q = False if q: print(i) 说明：素数指的是只能被1和自身整除的正整数（不包括1）。 函数的使用定义函数python123456789101112def factorial(num): \"\"\"求阶乘\"\"\" result = 1 for n in range(1, num + 1): result *= n return resultm = int(input('m = '))n = int(input('n = '))# 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数print(factorial(m) // factorial(n) // factorial(m - n)) python12def nop(): pass pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。 函数的参数位置参数python12def power(x, y): return x * y 默认参数python12def power(x, y=1): return x * y python1234567891011121314151617181920212223242526from random import randintdef roll_dice(n=2): \"\"\"摇色子\"\"\" total = 0 for _ in range(n): total += randint(1, 6) return totaldef add(a=0, b=0, c=0): \"\"\"三个数相加\"\"\" return a + b + c# 如果没有指定参数那么使用默认值摇两颗色子print(roll_dice())# 摇三颗色子print(roll_dice(3))print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))# 传递参数时可以不按照设定的顺序进行传递print(add(c=50, a=100, b=200)) 可变参数 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： python12345def calc(*numbers):#设置可变参数 sum = 0 for n in numbers: sum = sum + n * n return sum 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做： python123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])14 这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去： python123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 *nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。 关键字参数python12def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。 python12345678def person(name, age, **kw): if 'city' in kw: # 有city参数 pass if 'job' in kw: # 有job参数 pass print('name:', name, 'age:', age, 'other:', kw) 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： Code12def person(name, age, *, city, job): print(name, age, city, job) 和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了： python12def person(name, age, *args, city, job): print(name, age, args, city, job) 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数 参数组合 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 例子：所有类型参数组合 python123456789101112131415# conding:utf-8'''Date: 2020-03-09 00:05:25Author: chenLastEditTime: 2020-03-10 12:50:12'''def person(name, age, lpl=666, * args, city, job, **kw,): print(name, age, 'lpl ', lpl, args, city, job, kw)person('jack', 14, '牛逼', 'english', 'math', 'game', city='beijing', job='teacher', father='jack chen', mather='luck hou')# 输出 jack 14 lpl 牛逼 ('english', 'math', 'game') beijing teacher &#123;'father': 'jack chen', 'mather': 'luck hou'&#125; 组合２： python123456789101112131415161718192021222324252627def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) &gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;'ext': None&#125;#最神奇的是通过一个tuple和dict，你也可以调用上述函数：&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;'d': 88, 'x': '#'&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125; 例子：可接收一个或多个数并计算乘积 python12345678910111213141516171819202122232425def product(x, *kis): sum = x for i in kis: sum *= i return sumprint('product(5) =', product(5))print('product(5, 6) =', product(5, 6))print('product(5, 6, 7) =', product(5, 6, 7))print('product(5, 6, 7, 9) =', product(5, 6, 7, 9))if product(5) != 5: print('测试失败!')elif product(5, 6) != 30: print('测试失败!')elif product(5, 6, 7) != 210: print('测试失败!')elif product(5, 6, 7, 9) != 1890: print('测试失败!')else: try: product() print('测试失败!') except TypeError: print('测试成功!') 递归函数python12345def fact(n): if n==1: return 1 return n * fact(n - 1) 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)： python1234567&gt;&gt;&gt; fact(1000)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"&lt;stdin&gt;\", line 4, in fact ... File \"&lt;stdin&gt;\", line 4, in factRuntimeError: maximum recursion depth exceeded in comparison 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： python1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。 python12345678def move(n, a, b, c): # 汉诺塔 if n == 1: print(a, '--&gt;', c) else: move(n - 1, a, c, b) print(a, '--&gt;', c) move(n - 1, b, a, c) 函数格式python1234567def main(): # Todo: Add your code here passif __name__ == '__main__': main() python12345678910111213141516171819import mathdef quadratic(a, b, c): #返回一元二次方程 ax^2+bx+c=0的两个解。 x1 = (-b + math.sqrt(b ** 2 - 4 * a * c)) / (2 * a) x2 = (-b - math.sqrt(b ** 2 - 4 * a * c)) / (2 * a) return x1, x2print('quadratic(2, 3, 1) =', quadratic(2, 3, 1))print('quadratic(1, 3, -4) =', quadratic(1, 3, -4))if quadratic(2, 3, 1) != (-0.5, -1.0): print('测试失败')elif quadratic(1, 3, -4) != (1.0, -4.0): print('测试失败')else: print('测试成功') 高级特性切片利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法, 如果取 s[0]，代表这个 list 必须有该对应元素 如果取 s[:1]，python中的 [:] 有容错功能，比如一个 空，写成 list[:10] 也是允许的 python12345678910111213141516171819202122def trim(s): while s[-1:] == ' ': s = s[:-1] while s[:1] == ' ': s = s[1:] return sif trim('hello ') != 'hello': print('测试失败!')elif trim(' hello') != 'hello': print('测试失败!')elif trim(' hello ') != 'hello': print('测试失败!')elif trim(' hello world ') != 'hello world': print('测试失败!')elif trim('') != '': print('测试失败!')elif trim(' ') != '': print('测试失败!')else: print('测试成功!') 迭代如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 请使用迭代查找一个list中最小和最大值，并返回一个tuple： python1234567891011121314151617181920212223242526def findMinAndMax(L): if L: m = L[0] n = L[0] for i in L: if i &gt; m: m = i elif i &lt; n: n = i return n, m else: return (None, None)# 测试if findMinAndMax([]) != (None, None): print('测试失败!1')elif findMinAndMax([7]) != (7, 7): print('测试失败!2')elif findMinAndMax([7, 1]) != (1, 7): print('测试失败!3')elif findMinAndMax([7, 1, 3, 9, 5]) != (1, 9): print('测试失败!4')else: print('测试成功!') 生成式python12345678910#生成式f = [x for x in range(1, 10)]print(f)f = [x + y for x in 'ABCDE' for y in '1234567']print(f)# 用列表的生成表达式语法创建列表容器# 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间f = [x ** 2 for x in range(1, 1000)]print(sys.getsizeof(f)) # 查看对象占用内存的字节数print(f) python12345&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 == 0] #输出偶数[2, 4, 6, 8, 10]# if 放在 for后面的时候，不可以加else,在前面的时候要加else&gt;&gt;&gt; [x if x % 2 == 0 else -x for x in range(1, 11)][-1, 2, -3, 4, -5, 6, -7, 8, -9, 10] for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value： python1234567&gt;&gt;&gt; d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;&gt;&gt;&gt; for k, v in d.items():... print(k, '=', v)...y = Bx = Az = C 生成器通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： python123456789# 请注意下面的代码创建的不是一个列表而是一个生成器对象# 通过生成器可以获取到数据但它不占用额外的空间存储数据# 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)# 如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：如next(f)f = (x ** 2 for x in range(1, 1000))print(sys.getsizeof(f)) # 相比生成式生成器不占用存储数据的空间print(f)for val in f: print(val) 除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过yield关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成斐波拉切数列的生成器。 python1234567891011121314def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield a #普通情况此处写print(a),而改为yield后，a就变成生成器def main(): for val in fib(20): print(val)if __name__ == '__main__': main() 杨辉三角练习python12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364''' 1 / \\ 1 1 / \\ / \\ 1 2 1 / \\ / \\ / \\ 1 3 3 1 / \\ / \\ / \\ / \\ 1 4 6 4 1 / \\ / \\ / \\ / \\ / \\1 5 10 10 5 1'''def triangles(): a, n = [1], 1 while True: yield a b = [1] for i in range(n-1): b.append(a[i] + a[i + 1]) b.append(1) a = b[:] n += 1# 期待输出:# [1]# [1, 1]# [1, 2, 1]# [1, 3, 3, 1]# [1, 4, 6, 4, 1]# [1, 5, 10, 10, 5, 1]# [1, 6, 15, 20, 15, 6, 1]# [1, 7, 21, 35, 35, 21, 7, 1]# [1, 8, 28, 56, 70, 56, 28, 8, 1]# [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]n = 0results = []for t in triangles(): results.append(t) n = n + 1 if n == 10: breakfor t in results: print(t)if results == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1]]: print('测试通过!')else: print('测试失败!') 迭代器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： python1234567891011&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 把list、dict、str等Iterable变成Iterator可以使用iter()函数： python1234&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True 你可能会问，为什么list、dict、str等数据类型不是Iterator？ 这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。 凡是可作用于for循环的对象都是Iterable类型；凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 函数式编程高阶函数既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 一个最简单的高阶函数： python12345678def add(x, y, f): return f(x) + f(y)#当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为：#x = -5#y = 6#f = abs#f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11#return 1 map/reducemap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回 python1234567def f(x): return x * xr = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])print(list(r))#[1, 4, 9, 16, 25, 36, 49, 64, 81] reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： python123456789101112131415161718192021222324252627#reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)#例子1：from functools import reducedef fn(x, y): return x * 10 + yprint(reduce(fn, [1, 3, 5, 7, 9]))#13579#例子２,字符串转数字from functools import reduceDIGITS = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;def str2int(s): def fn(x, y): return x * 10 + y def char2num(s): return DIGITS[s] return reduce(fn, map(char2num, s))q = str2int('977096')print(q)#977096 练习 python1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']：from functools import reducedef normalize(name): q = name.lower().capitalize() return qL1 = ['adam', 'LISA', 'barT']L2 = list(map(normalize, L1))print(L2)#['Adam', 'Lisa', 'Bart']# Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积：'''#plan1def peod1(x, y): return x*ydef prod(L): return reduce(peod1, L)'''# plan2def prod(L): return reduce(lambda x, y: x * y, L)print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))if prod([3, 5, 7, 9]) == 945: print('测试成功!')else: print('测试失败!')# 利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456DIGITS = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;def str2float(s): i = s.find('.') point = len(s)-1-i s = s[:i] + s[i + 1:] def fn(x, y): return x * 10 + y def char2num(q): return DIGITS[q] return reduce(fn, map(char2num, iter(s)))*0.1**pointprint('str2float(\\'123.456\\') =', str2float('123.456'))if abs(str2float('123.456') - 123.456) &lt; 0.00001: print('测试成功!')else: print('测试失败!') filter 和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 filter和map对比差异如下： python123456789101112def is_odd(n): return n % 2 == 1print(list(map(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])))#[True, False, False, True, False, True, False, True]def is_odd(n): return n % 2 == 1print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])))#[1, 5, 9, 15] sorted 排序,sorted不改变原列表顺序,sort改变原列表顺序 python123456789&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36]#sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36]#默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' &lt; 'a'，结果，大写字母Z会排在小写字母a的前面,给sorted传入key函数，即可实现忽略大小写的排序&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)['about', 'bob', 'Credit', 'Zoo'] 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True ## 返回函数 高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回 python12345def calc_sum(*args): ax = 0 for n in args: ax = ax + n return ax 如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数： python1234567891011121314151617def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;&gt;&gt;&gt; f()25&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f1==f2False 我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数 python123456789101112131415161718def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()#在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9#全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变 python12345678910111213141516def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()1&gt;&gt;&gt; f2()4&gt;&gt;&gt; f3()9 匿名函数当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。 在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数： python12345&gt;&gt;&gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))[1, 4, 9, 16, 25, 36, 49, 64, 81]#匿名函数lambda x: x * x实际上就是def f(x): return x * x 关键字lambda表示匿名函数，冒号前面的x表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 装饰器 假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator） 作用域，是栋楼，下楼套上楼；读变量，往下搜，一直到一楼；改变量，莫下楼，除非你放global； 闭包：至少两层楼，楼下变量管上楼，return上楼不动手装饰器：客人空手来，还得请上楼；干啥都同意，有参给上楼 闭包 例子： python1234567891011121314x = 123def one(): def two(): global x #修改全局变量用global x += 1 print(x) return twoy = one()y() 装饰器 不接收参数 python123456789101112131415161718def one(name): def two(): print('程序开始执行') name() print('程序结束') return two@onedef dd(): print('我是原函数')dd()#程序开始执行#我是原函数#程序结束 ｀接收参数,可选参数，通过判断参数是字符串还是函数，选择不同的装饰器部分，传入n参数是字符串时，需要封装三层函数，传入参数是函数时，只需封装两层 装饰器会修改原函数的__name__属性，加上 @functools.wraps(func)后就可以修正原函数的属性__name__ python12345678910111213141516171819202122232425262728293031import functoolsdef log(test): if isinstance(test, str): def one(name): @functools.wraps(name) def two(): print('程序开始执行') print('%s() %s' % (name.__name__, test)) name() print('程序结束') return two return one else: @functools.wraps(test) def two(): print('程序开始执行') test() print('程序结束') return two@log # ('加了装饰器')def f(): print('我是原函数')f() ## 偏函数 例如：int()函数默认按十进制转换，但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换： python1234&gt;&gt;&gt; int('12345', base=8)5349&gt;&gt;&gt; int('12345', 16)74565 functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： Code123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85 所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 模块使用模块例子： module1.py python12def foo(): print('hello, world!') module2.py python12def foo(): print('goodbye, world!') test.py python123456789from module1 import foo# 输出hello, world!foo()from module2 import foo# 输出goodbye, world!foo() 也可以按照如下所示的方式来区分到底要使用哪一个foo函数。 test.py python12345import module1 as m1import module2 as m2m1.foo()m2.foo() 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是&quot;__main__&quot;。 module3.py python123456789101112131415def foo(): passdef bar(): pass# __name__是Python中一个隐含的变量它代表了模块的名字# 只有被Python解释器直接执行的模块的名字才是__main__if __name__ == '__main__': print('call foo()') foo() print('call bar()') bar() test.py python123import module3# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__ 导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：运行python3 hello.py获得的sys.argv就是[&#39;hello.py&#39;]；运行python3 hello.py Michael获得的sys.argv就是[&#39;hello.py&#39;, &#39;Michael]。 作用域在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等； 类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名； 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。 private函数或变量不应该被别人引用，那它们有什么用呢？请看例子： Code1234567891011def _private_1(name): return &apos;Hello, %s&apos; % namedef _private_2(name): return &apos;Hi, %s&apos; % namedef greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 安装第三方模块例如： sh1pip install Pillow 一个一个安装模块比较麻烦，推荐下载anaconda,常用命令和安装配置见 Anaconda配置 默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中： Code123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&apos;&apos;, &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip&apos;, &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&apos;, ..., &apos;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&apos;] 如果我们要添加自己的搜索目录，有两种方法： 一是直接修改sys.path，添加要搜索的目录： Code12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path.append(&apos;/Users/michael/my_py_scripts&apos;) 这种方法是在运行时修改，运行结束后失效。 第二种方法是设置环境变量PYTHONPATH，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。 面向对象定义把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。 类和对象简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。 类 面向对象有三大支柱：封装、继承和多态。 ## 类的创建方法 python1234567891011121314151617181920212223242526272829class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print('%s正在学习%s.' % (self.name, course_name)) # PEP 8要求标识符的名字用全小写多个单词用下划线连接 # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识) def watch_movie(self): if self.age &lt; 18: print('%s只能观看《熊出没》.' % self.name) else: print('%s正在观看岛国爱情大电影.' % self.name) def main(): # main函数,只有在直接执行本脚本时才会执行,作为类调用时不执行,与下一段if连用 student = Student('小明', 15) student.study('英语') student.watch_movie()if __name__ == \"__main__\": main() ## 调用方法(在同一目录): python123from test1 import Student as stdba = st('小明', 26)dba.watch_movie() ## 例子：定义一个类描述数字时钟 python123456789101112131415161718192021222324252627282930313233343536373839404142434445from time import sleepclass Clock(object): \"\"\"数字时钟\"\"\" def __init__(self, hour=0, minute=0, second=0): \"\"\"初始化方法 :param hour: 时 :param minute: 分 :param second: 秒 \"\"\" self._hour = hour self._minute = minute self._second = second def run(self): \"\"\"走字\"\"\" self._second += 1 if self._second == 60: self._second = 0 self._minute += 1 if self._minute == 60: self._minute = 0 self._hour += 1 if self._hour == 24: self._hour = 0 def show(self): \"\"\"显示时间\"\"\" return '%02d:%02d:%02d' % \\ (self._hour, self._minute, self._second)def main(): clock = Clock(23, 59, 58) while True: print(clock.show()) sleep(1) clock.run()if __name__ == '__main__': main()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://chinantfy.gitee.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"python基础命令","slug":"python基础命令","permalink":"https://chinantfy.gitee.io/tags/python%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"}]},{"title":"Anaconda配置及常用命令","slug":"08.anaconda配置及常用命令","date":"2020-01-11T12:11:18.000Z","updated":"2020-03-08T10:44:32.196Z","comments":true,"path":"2020/01/11/08.anaconda配置及常用命令/","link":"","permalink":"https://chinantfy.gitee.io/2020/01/11/08.anaconda%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"安装Code1sudo pacman -S anaconda 在 ~/.bashrc 中添加 Code1export PATH=/opt/anaconda/bin:$PATH 激活 Code1source /opt/anaconda/bin/activate root zsh修改 ~/.zshrc Code1export PATH=/opt/anaconda/bin:$PATH Code1source ~/.zshrc conda常用命令环境Code123456789101112# 创建一个名为python34的环境，指定Python版本是3.4conda create --name python34 python=3.4# 激活某个环境activate python34 # for Windowssource activate python34 # for Linux &amp; Macdeactivate python34 # for Windowssource deactivate python34 # for Linux &amp; Mac# 删除一个已有的环境conda remove -n python34 --all python环境目录 ~/anaconda/envs 查看已安装的环境 conda info -e 包管理Code1234567891011121314# 安装xxxxconda install xxxx# 查看当前环境下已安装的包conda list# 查看某个指定环境的已安装包conda list -n python34# 查找package信息conda search numpy# 安装packageconda install -n python34 numpy # 如果不用-n指定环境名称，则被安装在当前活跃环境 也可以通过-c指定通过某个channel安装 参考链接：https://blog.csdn.net/guan__hua/article/details/61240932 Conda 更新Code1234567891011121314# 更新packageconda update -n python34 numpy# 删除packageconda remove -n python34 numpy# 更新conda，保持conda最新conda update conda# 更新anacondaconda update anaconda# 更新pythonconda update python Conda 源Code123456# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址conda config --set show_channel_urls yes Clone环境Code123conda create -n BBB --clone ~/path或者conda create -n BBB --clone AAA pip中国源常用中国源： 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/ 临时使用Code1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider Windows下C:\\Users\\xx\\pip，新建文件pip.ini Code1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com Linux下~/.pip/pip.conf 没有就创建一个文件夹及文件 Code12mkdir -p ~/.pip/touch ~/.pip/pip.conf Code1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com","categories":[{"name":"manjaro","slug":"manjaro","permalink":"https://chinantfy.gitee.io/categories/manjaro/"}],"tags":[{"name":"anaconda","slug":"anaconda","permalink":"https://chinantfy.gitee.io/tags/anaconda/"},{"name":"pip中国源","slug":"pip中国源","permalink":"https://chinantfy.gitee.io/tags/pip%E4%B8%AD%E5%9B%BD%E6%BA%90/"},{"name":"conda","slug":"conda","permalink":"https://chinantfy.gitee.io/tags/conda/"}]},{"title":"Terminator配置","slug":"07.terminator配置","date":"2020-01-11T11:32:32.000Z","updated":"2020-02-24T15:36:17.904Z","comments":true,"path":"2020/01/11/07.terminator配置/","link":"","permalink":"https://chinantfy.gitee.io/2020/01/11/07.terminator%E9%85%8D%E7%BD%AE/","excerpt":"","text":"terminator 自用配置备份gedit ~/.config/terminator/config Code12345678910111213141516171819202122232425262728293031323334353637[global_config] focus = system suppress_multiple_term_dialog = True title_transmit_bg_color = &quot;#d30102&quot;[keybindings][layouts] [[default]] [[[child1]]] parent = window0 profile = default type = Terminal [[[window0]]] parent = &quot;&quot; type = Window[plugins][profiles] [[default]] background_color = &quot;#002b36&quot; background_darkness = 0.76 background_type = transparent copy_on_selection = True cursor_color = &quot;#eee8d5&quot; font = Hack 16 foreground_color = &quot;#839496&quot; palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot; show_titlebar = False use_system_font = False [[solarized-dark]] background_color = &quot;#002b36&quot; cursor_color = &quot;#eee8d5&quot; foreground_color = &quot;#839496&quot; palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot; [[solarized-light]] background_color = &quot;#fdf6e3&quot; cursor_color = &quot;#002b36&quot; foreground_color = &quot;#657b83&quot; palette = &quot;#073642:#dc322f:#859900:#b58900:#268bd2:#d33682:#2aa198:#eee8d5:#002b36:#cb4b16:#586e75:#657b83:#839496:#6c71c4:#93a1a1:#fdf6e3&quot; 效果图如下：","categories":[{"name":"manjaro","slug":"manjaro","permalink":"https://chinantfy.gitee.io/categories/manjaro/"}],"tags":[{"name":"terminator","slug":"terminator","permalink":"https://chinantfy.gitee.io/tags/terminator/"}]},{"title":"Hexo配置过程","slug":"05.hexo配置过程","date":"2019-11-17T16:06:02.000Z","updated":"2020-03-08T10:44:11.109Z","comments":true,"path":"2019/11/18/05.hexo配置过程/","link":"","permalink":"https://chinantfy.gitee.io/2019/11/18/05.hexo%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/","excerpt":"","text":"更换next主题hexo根目录执行 Code1git clone https://github.com/theme-next/hexo-theme-next themes/next 修改hexo配置文件 Code1gedit _config.yml #或者vim_config.yml 修改 Code1theme: next Code1hexo s 增加标签和分类修改主题的配置文件 Code1gedit ./themes/next/_config.yml 修改 Code1scheme: Mist #主题细类 下面三行去掉前面的#号 Code123tags: /tags/ || tags #标签categories: /categories/ || th #分类archives: /archives/ || archive #归档 hexo根目录执行命令，创建标签和分类的目录 Code12hexo new page &quot;archives&quot;hexo new page &quot;tags&quot; 修改标签目录下的md文件 Code1gedit ./source/tags/index.md 内容修改如下： Code12345---title: 标签date: 2019-11-13 00:05:40type: tags--- 同理分类目录下的md文件修改为 Code12345---title: 分类date: 2019-11-13 00:04:08type: categories--- Code1hexo clean &amp;&amp; hexo g #重新生成配置文件 在博客的md文件中开头加入 Code123456---title: hexo配置过程date: 2019-11-18 00:06:02categories: hexotags: --- 博客就会自动添加进分类和标签目录 添加本地搜索安装插件 Code1npm install hexo-generator-searchdb --save 修改博客配置文件 Code1gedit _config.yml 添加 Code12345search: path: search.xml field: post format: html limit: 10000 修改主题配置文件 Code1gedit ./themes/next/_config.yml Code12local_search: enable: true 重新部署就可以使用搜索功能 Butterfly主题 文章置顶设置 打开hexo 工作目录 npm uninstall hexo-generator-index –save 然后 npm install hexo-generator-index-pin-top –save 在文章的front-matter区域添加top: True属性 可以参考 hexo-generator-index-pin-top仓库了解更多细节。 例如： Code1234567title: xxxxtags: - xxxdate: 2018-08-08 08:08:08top: True---// .... 来源参考：https://jerryc.me/posts/21cfbf15/","categories":[{"name":"hexo","slug":"hexo","permalink":"https://chinantfy.gitee.io/categories/hexo/"}],"tags":[]},{"title":"Hexo博客中加入图片","slug":"06.hexo博客中加入图片","date":"2019-11-17T13:06:02.000Z","updated":"2020-03-08T10:44:21.196Z","comments":true,"path":"2019/11/17/06.hexo博客中加入图片/","link":"","permalink":"https://chinantfy.gitee.io/2019/11/17/06.hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BE%E7%89%87/","excerpt":"","text":"编辑hexo配置文件_config.yml post_asset_folder: true 运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，博客用到的图片放到同名文件夹内，博客md文件中调用时直接用 Code1&#123;% asset_img 7.png This is an example image %&#125; 其中7.png是图片名字，md文件中无法预览，但是生成的博客中可以看到","categories":[{"name":"hexo","slug":"hexo","permalink":"https://chinantfy.gitee.io/categories/hexo/"}],"tags":[{"name":"hexo博客中加入图片","slug":"hexo博客中加入图片","permalink":"https://chinantfy.gitee.io/tags/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%8A%A0%E5%85%A5%E5%9B%BE%E7%89%87/"}]},{"title":"MANJARO 安装nexo并部署到码云","slug":"04.安装nexo并部署到码云","date":"2019-11-16T16:00:00.000Z","updated":"2020-02-24T15:36:17.904Z","comments":true,"path":"2019/11/17/04.安装nexo并部署到码云/","link":"","permalink":"https://chinantfy.gitee.io/2019/11/17/04.%E5%AE%89%E8%A3%85nexo%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E7%A0%81%E4%BA%91/","excerpt":"","text":"确认node.js环境以及它的包管理工具是否安装成功Code123node --versionnpm --version #manjaro默认没有按照npm，需要执行sudo pacman -S npm 安装git --version 将npm的下载源更换为国内的淘宝镜像Code1npm config set registry https://registry.npm.taobao.org 通过npm来安装HexoCode1sudo npm install -g hexo-cli #亲测不用sudo的话manjaro下会提示无权限 搭建hexo博客Code123hexo init blog #注意：执行此命令后会在当前目录下新建blog文件夹cd blogls -lR 生成博客Code1hexo g 启动博客服务Code1hexo s 服务启动后显示如下 Code12INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 这时候用浏览器访问http://localhost:4000 就可以访问刚刚搭建的本地hexo博客，Ctrl+C停止服务; 如果要修改服务器使用的端口，可以在启动服务器的时候加上-p参数；如果希望服务器启动后，自动打开默认的浏览器访问服务器，可以使用-o参数，如下所示。 Code1hexo s -p 8000 -o 修改博客配置文件Code1vim _config.yml 下面是YAML文件中相关选项的说明。 参数 描述 title 网站的标题 subtitle 网站的副标题 description 网站的描述 keywords 网站的关键词，可以用逗号分隔多个关键词 author 自己的名字 language 网站使用的语言 timezone 网站使用时区，默认使用电脑上设置的时区 url 网址 root 网站根目录 source_dir 资源文件夹，这个文件夹用来存放内容，默认source目录 public_dir 公共文件夹，这个文件夹用于存放生成的站点文件，默认public目录 tag_dir 标签文件夹，默认tags目录 archive_dir 归档文件夹，默认archives目录 category_dir 分类文件夹，默认categories目录 auto_spacing 在中文和英文之间加入空格，默认false titlecase 把标题转换为首字母大写，默认false external_link 在新标签中打开链接，默认true relative_link 把链接改为与根目录的相对位址，默认false default_category 默认分类 date_format 日期格式，默认YYYY-MM-DD time_format 时间格式，默认HH:mm:ss per_page 每页显示的文章数量 ，默认值10，0表示不使用分页 pagination_dir 分页目录，默认为page目录 theme 当前主题名称 deploy 部署部分的设置 我们将编写好的Markdown文件可以拷贝到source/_posts目录，我们可以在每个Markdown文件的上方添加Front-matter来对文件的布局、标题、分类、标签、发布日期等信息加以说明。所谓Front-matter，就是每个Markdown文件最上方以—分隔的区域，可以在Front-matter中设置以下内容。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 例如： Code123456789101112131415---title: Python编程惯例category: Python基础date: 2019-8-1---# Python惯例“惯例”这个词指的是“习惯的做法，常规的办法，一贯的做法”，与这个词对应的英文单词叫“idiom”。由于Python跟其他很多编程语言在语法和使用上还是有比较显著的差别，因此作为一个Python开发者如果不能掌握这些惯例，就无法写出“Pythonic”的代码。下面我们总结了一些在Python开发中的惯用的代码。1. 让代码既可以被导入又可以被执行。 if __name__ == &apos;__main__&apos;:2. 用下面的方式判断逻辑“真”或“假”。 if x: if not x: 完成之后执行如下命令重启hexo服务 Code1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 托管到码云在码云新建仓库hexo修改博客项目的配置文件_config.ymlCode1vim _config.yml Code1234567# 省略上面的内容# Deployment# Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://gitee.com/chinantfy/hexo.git branch: master 上面的配置中，type指定了使用git进行项目部署，repo指定了部署项目的git仓库的URL，我们这里使用的是HTTPS的地址，如果之前配置过密钥对也可以使用SSH的地址，branch指定了将代码同步到仓库中的哪一个分支，通常master分支就是发布项目最终工作成果的分支，也称为项目的主分支。##3.上面的配置中，type指定了使用git进行项目部署，repo指定了部署项目的git仓库的URL，我们这里使用的是HTTPS的地址，如果之前配置过密钥对也可以使用SSH的地址，branch指定了将代码同步到仓库中的哪一个分支，通常master分支就是发布项目最终工作成果的分支，也称为项目的主分支。 Code1npm install hexo-deployer-git --save 设置gitee账号和邮箱Code12git config --global user.name &quot;YourName&quot; git config --global user.email &quot;email@example.com&quot; 可以使用下面的命令来实现一键部署到GiteeCode123hexo deploy -g或者hexo generate -d 如果没有配置ssh秘钥，此处会需要输入gitee账号和密码 开启gitee.pages码云仓库主界面点击服务》gitee pages 访问https://chinantfy.gitee.io/hexo 就可以打开博客，之后每次修改博客内容之后需要更新Gitee Pages。 访问码云的博客地址css不起作用，本地博客显示正常 解决方法： 编辑博客配置文件_config.yml root: / 修改为 root: /hexo/ hexo是码云的项目名称 修改完之后 Code12hexo clean &amp;&amp; hexo g hexo deploy -g 码云上的博客就访问正常了 配置gitee ssh秘钥生成秘钥对Code1ssh-keygen -t rsa -C &quot;email@example.com&quot; 连按三次enter键，会看到生成了 一个id_rsa.pub文件 将秘钥添加码云Code1cat ~/.ssh/id_rsa.pub 复制秘钥内容粘贴地址 https://gitee.com/profile/sshkeys 测试秘钥连接Code1ssh -T git@gitee.com manjaro18.1 报错如下 Code1vim ~/.ssh/config 文件添加一句 Code1IPQoS lowdelay throughput 再次执行ssh -T git@gitee.com 会显示 修改博客访问gitee方式为ssh修改博客项目的配置文件_config.yml Code12repo: https://gitee.com/chinantfy/hexo.git 修改为repo: git@gitee.com:chinantfy/hexo.git #更换gitee登陆方式为ssh 再执行 Code1hexo deploy -g 这时候就不要输入账号密码了 npm报错 fseventsnpm报错 fsevents，忽略即可npm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.9 (node_modules/nunjucks/node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.9: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”linux”,”arch”:”x64”})npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 (node_modules/fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”linux”,”arch”:”x64”})","categories":[{"name":"manjaro","slug":"manjaro","permalink":"https://chinantfy.gitee.io/categories/manjaro/"},{"name":"hexo","slug":"hexo","permalink":"https://chinantfy.gitee.io/categories/hexo/"}],"tags":[{"name":"manjaro安装nexo并部署到码云","slug":"manjaro安装nexo并部署到码云","permalink":"https://chinantfy.gitee.io/tags/manjaro%E5%AE%89%E8%A3%85nexo%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0%E7%A0%81%E4%BA%91/"},{"name":"访问码云的博客地址css不起作用但是本地博客显示正常","slug":"访问码云的博客地址css不起作用但是本地博客显示正常","permalink":"https://chinantfy.gitee.io/tags/%E8%AE%BF%E9%97%AE%E7%A0%81%E4%BA%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80css%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E4%BD%86%E6%98%AF%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E6%98%BE%E7%A4%BA%E6%AD%A3%E5%B8%B8/"},{"name":"npm报错 fsevents","slug":"npm报错-fsevents","permalink":"https://chinantfy.gitee.io/tags/npm%E6%8A%A5%E9%94%99-fsevents/"},{"name":"manjaro连接ssh gitee 报错Broken pipe","slug":"manjaro连接ssh-gitee-报错Broken-pipe","permalink":"https://chinantfy.gitee.io/tags/manjaro%E8%BF%9E%E6%8E%A5ssh-gitee-%E6%8A%A5%E9%94%99Broken-pipe/"}]},{"title":"Visual Code去除标题栏","slug":"03.vscode去除标题栏","date":"2019-11-11T19:32:32.000Z","updated":"2020-03-08T10:43:54.692Z","comments":true,"path":"2019/11/12/03.vscode去除标题栏/","link":"","permalink":"https://chinantfy.gitee.io/2019/11/12/03.vscode%E5%8E%BB%E9%99%A4%E6%A0%87%E9%A2%98%E6%A0%8F/","excerpt":"","text":"在设置Visual Studio Code的窗口中，有Title Bar Style选项可以设置,选择custom ，就可以去掉大大的标题栏，其他系统中此方法应该也可以。","categories":[{"name":"manjaro","slug":"manjaro","permalink":"https://chinantfy.gitee.io/categories/manjaro/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://chinantfy.gitee.io/tags/vscode/"}]},{"title":"MANJARO 命令审计","slug":"02.MANJARO命令审计","date":"2019-11-11T18:32:32.000Z","updated":"2020-02-24T15:36:17.904Z","comments":true,"path":"2019/11/12/02.MANJARO命令审计/","link":"","permalink":"https://chinantfy.gitee.io/2019/11/12/02.MANJARO%E5%91%BD%E4%BB%A4%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"bash下配置最近在折腾manjaro xfce 版本，实现命令审计参考如下博客https://blog.51cto.com/13227377/2159238具体操作如下:在/etc/profile后面添加 Code123456#historyexport HISTSIZE=4096DT=`date +&quot;%Y-%m-%d&quot;`export HISTFILE=&quot;/opt/history/$&#123;LOGNAME&#125;_history.log&quot;chmod 600 /opt/history/$&#123;LOGNAME&#125; 2&gt;/dev/nullexport PROMPT_COMMAND=&apos;&#123; date &quot;+%Y-%m-%d %T #### $(whoami) #### $(history 1 | &#123; read x cmd; echo &quot;$cmd&quot;; &#125;)&quot;; &#125;&gt;&gt;$HISTFILE&apos; 添加完发现PROMPT_COMMAND变量没有生效，也就是打开log文件里log的记录格式没有改变，后来发现用户环境变量重置了PROMPT_COMMAND第一步：Code1sudo gedit /etc/bash.bashrc 将下面这一段注释掉 Code123456789#case $&#123;TERM&#125; in# xterm*|rxvt*|Eterm|aterm|kterm|gnome*)# PROMPT_COMMAND=$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND; &#125;&apos;printf &quot;\\033]0;%s@%s:%s\\007&quot; &quot;$&#123;USER&#125;&quot; &quot;$&#123;HOSTNAME%%.*&#125;&quot; &quot;$&#123;PWD/#$HOME/\\~&#125;&quot;&apos;# ;;# screen*)# PROMPT_COMMAND=$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND; &#125;&apos;printf &quot;\\033_%s@%s:%s\\033\\\\&quot; &quot;$&#123;USER&#125;&quot; &quot;$&#123;HOSTNAME%%.*&#125;&quot; &quot;$&#123;PWD/#$HOME/\\~&#125;&quot;&apos;# ;;#esac 第二步：Code1gedit ~/.bashrc 将下面这一段注释掉 Code123456789# Change the window title of X terminals#case $&#123;TERM&#125; in# xterm*|rxvt*|Eterm*|aterm|kterm|gnome*|interix|konsole*)# PROMPT_COMMAND=&apos;echo -ne &quot;\\033]0;$&#123;USER&#125;@$&#123;HOSTNAME%%.*&#125;:$&#123;PWD/#$HOME/\\~&#125;\\007&quot;&apos;# ;;# screen*)# PROMPT_COMMAND=&apos;echo -ne &quot;\\033_$&#123;USER&#125;@$&#123;HOSTNAME%%.*&#125;:$&#123;PWD/#$HOME/\\~&#125;\\033\\\\&quot;&apos;# ;;#esac 第三步：Code12source /etc/bash.bashrcsource ~/.bashrc 这一刻history.log中的格式就已经改为命令审计中设置的格式 zsh配置Code12sudo mkdir -p /opt/history/sudo chmod 777 /opt/history gedit ~/.zshrc Code123456#historyexport HISTSIZE=4096DT=`date +&quot;%Y-%m-%d&quot;`export HISTFILE=&quot;/opt/history/$&#123;LOGNAME&#125;_history.log&quot;chmod 600 /opt/history/$&#123;LOGNAME&#125; 2&gt;/dev/nullexport PROMPT_COMMAND=&apos;&#123; date &quot;+%Y-%m-%d %T #### $(whoami) #### $(history 1 | &#123; read x cmd; echo &quot;$cmd&quot;; &#125;)&quot;; &#125;&gt;&gt;$HISTFILE&apos; Code12source ~/.zshrc`` 查看history Code1fc -li","categories":[{"name":"manjaro","slug":"manjaro","permalink":"https://chinantfy.gitee.io/categories/manjaro/"}],"tags":[]},{"title":"MANJARO 安装配置","slug":"01.MANJARO安装配置","date":"2019-11-11T16:00:01.000Z","updated":"2020-03-12T14:18:56.183Z","comments":true,"path":"2019/11/12/01.MANJARO安装配置/","link":"","permalink":"https://chinantfy.gitee.io/2019/11/12/01.MANJARO%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"更改manjaro的国内源Code12sudo pacman-mirrors -i -c China -m ranksudo pacman -Syy 设置archlinux国内源Code12sudo pacman -S geditsudo gedit /etc/pacman.conf 写入如下内容 Code123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 执行命令： Code12sudo pacman -Syy sudo pacman -S archlinuxcn-keyring 更改项目文件英文名Code1234sudo pacman -S xdg-user-dirs-gtkexport LANG=en_USxdg-user-dirs-gtk-update #然后会有个窗口提示语言更改，更新名称即可export LANG=zh_CN.UTF-8 #然后重启电脑如果提示语言更改，保留旧的名称即可 安装搜狗输入法Code1234sudo pacman -S fcitx-im sudo pacman -S fcitx-configtoolsudo pacman -S fcitx-sogoupinyinsudo pacman -S fcitx-qt4 注意：截至到2019.07.07，搜狗拼音的版本fcitx-sogoupiny为2.2.X，需要fcitx-qt4支持，但是ArchLinux已经从Comminuty库中删除了fcitx-qt4，默认会安装fcitx-qt5，因此搜狗输入法安装后不会起作用，我这里是重新安装了fcitx-qt4，配置完成之后搜狗输入法可以正常使用 配置环境变量Code1sudo gedit ~/.xprofile 写入如下内容： Code123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 重启电脑之后搜狗输入法就可以正常使用了 安装常用软件Code12345678910111213141516171819202122232425262728sudo pacman -S yaysudo hwclock --systohc --localtime #解决双系统时间不一致问题sudo pacman -S base-devel #安装deepin微信需要的依赖yay -S deepin.com.qq.officeyay -S deepin-wine-wechatsudo pacman -S electronic-wechatsudo pacman -S visual-studio-code-binsudo pacman -S deepin-screenshot #深度截图sudo pacman -S deepin-terminal #深度终端sudo pacman -S deepin-file-manager #深度文件管理器sudo pacman -S deepin-editor #深度编辑器sudo pacman -S screenfetchsudo pacman -S google-chromesudo pacman -S open-vm-tools #虚拟机安装vmware-toolssudo pacman -S pepper-flashsudo pacman -S flashpluginsudo pacman -S wps-officesudo pacman -S ttf-wps-fontssudo pacman -S thefucksudo pacman -S terminatorsudo pacman -S anacondasudo pacman -S typorayay -S wps-office-mui-zh-cn #解决wps默认显示为英文问题sudo pacman -S netease-cloud-musicpacman -S --noconfirm XXX # --noconfirm隐藏每次安装软解时的是否确认安装提示sudo pacman -S clang make cmake gdb # 编译调试环境sudo pacman -S vim # 命令行下的编辑器sudo visudo 在文件的最后一行加入：用户名 ALL=(ALL) NOPASSWD: ALL #取消sudo输入密码 解决网易云音乐无法输入中文参考 https://aur.archlinux.org/packages/netease-cloud-music/大致思路：使用@springzfx 提供的代码编译qcef， https://github.com/springzfx/archlinux/tree/master/netease-cloud-music 使用@laomocode 提供的PKGBUILD文件编译安装网易云音乐 https://gitee.com/laomocode/netease-cloud-music，完美解决分别下载两个链接中的文件夹 Code1234567891011121314#安装依赖sudo pacman -S gconfsudo pacman -S qt5-webchannelsudo pacman -S cmakesudo pacman -S qt5-tools#编译qcer1719108869217191088692cd qcefmakepkg -sicd netease-cloud-musicmakepkg -sisudo gedit /opt/netease/netease-cloud-music/netease-cloud-music.bash将下面第一句注释掉，并加入第二句#export LD_LIBRARY_PATH=&quot;$&#123;HERE&#125;&quot;/libsexport LD_LIBRARY_PATH=/usr/lib 此时无法输入中文的问题已解决 解决网易云音乐双标题栏问题在网易云音乐桌面图标右键》编辑启动器》把命令修改为 Code1env XDG_CURRENT_DESKTOP=DDE netease-cloud-music %U 解决网易云音乐打开默认全屏，无法缩小窗口参考 https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=155383&amp;extra= 删除 ~/.cache/netease-cloud-music 目录 安装中文字体Code123sudo pacman -S wqy-bitmapfont wqy-microhei wqy-microhei-lite wqy-zenheisudo pacman -S noto-fonts-cjk adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fontssudo pacman -S ttf-ubuntu-font-family 美化主题包安装Code12345sudo pacman -S paper-icon-themesudo pacman -S mcmojave-circle-icon-theme-gitsudo pacman -S human-icon-themesudo pacman -S deepin-iconthemes-manjarosudo pacman -S andromeda-icon-theme pacman 常用命令Code12345678910111213pacman -S package_name # 安装软件 pacman -S extra/package_name # 安装不同仓库中的版本pacman -Syu # 升级整个系统，y是更新数据库，yy是强制更新，u是升级软件pacman -Ss string # 在包数据库中查询软件pacman -Si package_name # 显示软件的详细信息pacman -Sc # 清除软件缓存，即/var/cache/pacman/pkg目录下的文件pacman -R package_name # 删除单个软件pacman -Rs package_name # 删除指定软件及其没有被其他已安装软件使用的依赖关系pacman -Qs string # 查询已安装的软件包pacman -Qi package_name # 查询本地安装包的详细信息pacman -Ql package_name # 获取已安装软件所包含的文件的列表pacman -U package.tar.zx # 从本地文件安装pactree package_name # 显示软件的依赖树 安装oh-my-zshCode1234sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting zsh配置文件备份： ~/.zshrc sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# If you come from bash you might have to change your $PATH.# export PATH=$HOME/bin:/usr/local/bin:$PATH# Path to your oh-my-zsh installation.export ZSH=\"/home/chen/.oh-my-zsh\"# Set name of the theme to load --- if set to \"random\", it will# load a random theme each time oh-my-zsh is loaded, in which case,# to know which specific one was loaded, run: echo $RANDOM_THEME# See https://github.com/ohmyzsh/ohmyzsh/wiki/ThemesZSH_THEME=\"ys\"# Set list of themes to pick from when loading at random# Setting this variable when ZSH_THEME=random will cause zsh to load# a theme from this variable instead of looking in ~/.oh-my-zsh/themes/# If set to an empty array, this variable will have no effect.# ZSH_THEME_RANDOM_CANDIDATES=( \"robbyrussell\" \"agnoster\" )# Uncomment the following line to use case-sensitive completion.# CASE_SENSITIVE=\"true\"# Uncomment the following line to use hyphen-insensitive completion.# Case-sensitive completion must be off. _ and - will be interchangeable.# HYPHEN_INSENSITIVE=\"true\"# Uncomment the following line to disable bi-weekly auto-update checks.# DISABLE_AUTO_UPDATE=\"true\"# Uncomment the following line to automatically update without prompting.# DISABLE_UPDATE_PROMPT=\"true\"# Uncomment the following line to change how often to auto-update (in days).# export UPDATE_ZSH_DAYS=13# Uncomment the following line if pasting URLs and other text is messed up.# DISABLE_MAGIC_FUNCTIONS=true# Uncomment the following line to disable colors in ls.# DISABLE_LS_COLORS=\"true\"# Uncomment the following line to disable auto-setting terminal title.# DISABLE_AUTO_TITLE=\"true\"# Uncomment the following line to enable command auto-correction.# ENABLE_CORRECTION=\"true\"# Uncomment the following line to display red dots whilst waiting for completion.# COMPLETION_WAITING_DOTS=\"true\"# Uncomment the following line if you want to disable marking untracked files# under VCS as dirty. This makes repository status check for large repositories# much, much faster.# DISABLE_UNTRACKED_FILES_DIRTY=\"true\"# Uncomment the following line if you want to change the command execution time# stamp shown in the history command output.# You can set one of the optional three formats:# \"mm/dd/yyyy\"|\"dd.mm.yyyy\"|\"yyyy-mm-dd\"# or set a custom format using the strftime function format specifications,# see 'man strftime' for details.# HIST_STAMPS=\"mm/dd/yyyy\"# Would you like to use another custom folder than $ZSH/custom?# ZSH_CUSTOM=/path/to/new-custom-folder# Which plugins would you like to load?# Standard plugins can be found in ~/.oh-my-zsh/plugins/*# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/# Example format: plugins=(rails git textmate ruby lighthouse)# Add wisely, as too many plugins slow down shell startup.plugins=(git z vscode zsh-autosuggestions zsh-syntax-highlighting sudo history thefuck extract)source $ZSH/oh-my-zsh.sh# User configuration# export MANPATH=\"/usr/local/man:$MANPATH\"# You may need to manually set your language environment# export LANG=en_US.UTF-8# Preferred editor for local and remote sessions# if [[ -n $SSH_CONNECTION ]]; then# export EDITOR='vim'# else# export EDITOR='mvim'# fi# Compilation flags# export ARCHFLAGS=\"-arch x86_64\"# Set personal aliases, overriding those provided by oh-my-zsh libs,# plugins, and themes. Aliases can be placed here, though oh-my-zsh# users are encouraged to define aliases within the ZSH_CUSTOM folder.# For a full list of active aliases, run `alias`.## Example aliases# alias zshconfig=\"mate ~/.zshrc\"# alias ohmyzsh=\"mate ~/.oh-my-zsh\"#historyexport HISTSIZE=4096DT=`date +\"%Y-%m-%d\"`export HISTFILE=\"/opt/history/$&#123;LOGNAME&#125;_history.log\"chmod 600 /opt/history/$&#123;LOGNAME&#125; 2&gt;/dev/nullexport PROMPT_COMMAND='&#123; date \"+%Y-%m-%d %T #### $(whoami) #### $(history 1 | &#123; read x cmd; echo \"$cmd\"; &#125;)\"; &#125;&gt;&gt;$HISTFILE'export PATH=\"/home/chen/.conda/envs/py37/bin:/opt/anaconda/bin:$PATH\"alias hr='hexo clean &amp;&amp; hexo g &amp;&amp; hexo s'alias hp='hexo deploy -g'alias py37='source activate py37'alias edit='deepin-editor'HIST_STAMPS=\"yyyy-mm-dd\" 终端代理（本人已弃用此方法，改用v2raya）Code1yay -S proxychains-ng 编辑proxychains.conf文件，将socks4 127.0.0.1 9095修改为socks5 127.0.0.1 1080 Code123sudo gedit /etc/proxychains.conf#找到最后一行，修改为socks5 127.0.0.1 1080 用法 Code1proxychains curl www.google.com 参考链接https://oceandlnu.github.io/2018/05/29/Manjaro%20%E6%97%A5%E5%B8%B8%E9%85%8D%E7%BD%AE/ 科学上网Code1yay -S v2raya 点击v2raya图标,会自动打开浏览器管理ssr配置，配置ssr链接后终端和浏览器都可以科学上网，配置中全局透明代理和pac模式可以选择大陆白名单或者GFWlist Code1234567891011121314# 开机自启systemctl enable v2raya# 取消自启systemctl disable v2raya# 启动服务systemctl start v2raya# 停止服务systemctl stop v2raya# 重启服务systemctl restart v2raya# 查看状态systemctl status v2raya# 查看日志journalctl -u v2raya 项目地址 ： https://github.com/mzz2017/V2RayA 安装vmwarezsh1234567891011sudo pacman -S fuse2 gtkmm pcsclite libcanberra #安装依赖sudo pacman -S linux54-headers #先通过uname -r 确认内核版本，选择对应版本的linux-headers,如我的电脑是5.4.22-1-MANJARO，则安装linux54yay -S --noconfirm --needed ncurses5-compat-libsyay -S vmware-workstation#启动服务sudo systemctl enable vmware-networks.service vmware-usbarbitrator.service vmware-hostd.servicesudo systemctl start vmware-networks.service vmware-usbarbitrator.service vmware-hostd.service#检查服务sudo systemctl status vmware-networks.service vmware-usbarbitrator.service vmware-hostd.service#检查服务后会有个别服务显示未启动，重启主机后所有服务正常启动sudo reboot 解决vmware for linux运行虚拟机卡顿的问题vmware安装完成之后发现同一个虚拟机文件，在Windows系统的vmware中不卡顿，在manjaro中非常卡顿，解决方法如下： Edit -&gt; Preferences -&gt; Memory，在Additional Memory选项中，选择第一项 Fit all virtual machine memory into reserved host RAM #更改此选项需要root用户允行vmware sudo vmware 然后修改上述信息即可 参考链接 https://insidelinuxdev.net/article/a06amj.html 中文字体渲染美化 + 去模糊 解压 freetype2-ultimate5.tar.gz 和 lib32-freetype2-ultimate5.tar.gz 两个压缩包，分别按照里面的《安装方法》操作； 解压安装 lulinux_fontsConf_181226.tar.gz，按里面的安装说明操作； 开启字体渲染： 打开 外观，更改字体 默认字体：微软雅黑 Regular默认等宽自体：Monospace Regular启用抗锯齿 &gt; 提示：全部 文件链接: https://pan.baidu.com/s/1BpQ9KDc-RUZNclSNFnfknA 提取码: kaiy xfce更换dde(deepin桌面)sh1234567sudo pacman -S deepin deepin-extra #安装ddesudo cp /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak #备份lightdm配置文件#修改配置文件中环境为ddesudo sed -i 's/greeter-session=lightdm-.*/greeter-session=lightdm-deepin-greeter/g' /etc/lightdm/lightdm.confsudo sed -i 's/user-session=xfce/user-session=deepin/g' /etc/lightdm/lightdm.conf#重启，右下角选择dde#如重启后还是进入xfce，则将配置文件中autologin-user一行注释掉 dde中gtk主题无法切换在dde设置中切换主题后，只能修改启动器中图标，桌面图标修改不生效，查阅资料发现manjaro有自己的qt主题设置程序，与dde设置冲突，在启动器中搜索Qt5设置修改图标和字体后manjaro的dde环境桌面图标就修改了，成品如下： 卸载原xfce桌面组件sh1sudo pacman -Rcs xfce4 双显示器设置开机默认显示器我的电脑是笔记本外接显示器，在系统设置中已经关闭笔记本显示器，但是每次锁屏或者重启需要输入密码的时候，笔记本显示器都会自动打开，解决方法如下 sh123sudo gedit /etc/lightdm/lightdm.conf #修改lightdm配置文件#增加一行display-setup-script=xrandr --output HDMI1 --primary Aria2+AriaNgCode123456sudo pacman -S aria2 #安装aria2mkdir ~/aria2 #建立配置目录，下面配置文件中的input-file，save-session，on-download-complete都用到了此目录cd ~/aria2touch aria2.conf #创建配置文件touch aria2.session #创建下载记录gedit aria2.conf #修改配置文件 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# touch /data/aria2.session# vim /etc/aria2/aria2.conf## &apos;#&apos;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 #### 被注释的选项填写的是默认值, 建议在需要修改时再取消注释 #### 文件保存相关 ### 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置dir=/home/Downloads/ # 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M#disk-cache=32M#disk-cache=32M# 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc# 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc# falloc和trunc则需要文件系统和内核支持# NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项file-allocation=prealloc# 断点续传continue=true## 下载连接相关 ### 最大同时下载任务数, 运行时可修改, 默认:5max-concurrent-downloads=10# 同一服务器连接数, 添加时可指定, 默认:1max-connection-per-server=10# 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M# 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载min-split-size=10M# 单个任务最大线程数, 添加时可指定, 默认:5split=5# 整体下载速度限制, 运行时可修改, 默认:0#max-overall-download-limit=0# 单个任务下载速度限制, 默认:0#max-download-limit=0# 整体上传速度限制, 运行时可修改, 默认:0#max-overall-upload-limit=0# 单个任务上传速度限制, 默认:0#max-upload-limit=0# 禁用IPv6, 默认:falsedisable-ipv6=true## 进度保存相关 ### 从会话文件中读取下载任务input-file=/home/chen/aria2/aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=/home/chen/aria2/aria2.session# 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0save-session-interval=60## RPC相关设置 ##enable-rpc=truepause=falserpc-allow-origin-all=truerpc-listen-all=truerpc-save-upload-metadata=truerpc-secure=false# 启用RPC, 默认:false#enable-rpc=true# 允许所有来源, 默认:false#rpc-allow-origin-all=true# 允许非外部访问, 默认:false#rpc-listen-all=true# 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同#event-poll=select# RPC监听端口, 端口被占用时可以修改, 默认:6800rpc-listen-port=6800# 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项#rpc-secure=191278299# 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-user=&lt;USER&gt;# 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项#rpc-passwd=&lt;PASSWD&gt;## BT/PT下载相关 ### 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true#follow-torrent=true# BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999listen-port=51413# 单个种子最大连接数, 默认:55#bt-max-peers=55# 打开DHT功能, PT需要禁用, 默认:trueenable-dht=true# 打开IPv6 DHT功能, PT需要禁用#enable-dht6=false# DHT网络监听端口, 默认:6881-6999#dht-listen-port=6881-6999# 本地节点查找, PT需要禁用, 默认:falsebt-enable-lpd=true# 种子交换, PT需要禁用, 默认:trueenable-peer-exchange=false# 每个种子限速, 对少种的PT很有用, 默认:50K#bt-request-peer-speed-limit=50K# 客户端伪装, PT需要#peer-id-prefix=-TR2770-user-agent=Transmission/2.92#user-agent=netdisk;4.4.0.6;PC;PC-Windows;6.2.9200;WindowsBaiduYunGuanJia# 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0seed-ratio=1.0#作种时间大于30分钟，则停止作种seed-time=30# 强制保存会话, 话即使任务已经完成, 默认:false# 较新的版本开启后会在任务完成后依然保留.aria2文件#force-save=false# BT校验相关, 默认:true#bt-hash-check-seed=true# 继续之前的BT任务时, 无需再次校验, 默认:falsebt-seed-unverified=true# 保存磁力链接元数据为种子文件(.torrent文件), 默认:falsebt-save-metadata=true#下载完成后删除.ara2的同名文件on-download-complete=/home/chen/aria2/delete_aria2#on-download-complete=/home/pi/aria2/rasp.sh Code12sudo touch /lib/systemd/system/aria2.servicesudo gedit /lib/systemd/system/aria2.service Code123456789101112[Unit]Description= aria2After=network.target [Service]#PIDFile=/run/aria2.pidExecStart=aria2c -c --conf-path=/home/chen/aria2/aria2.conf &amp;ExecStop=/bin/kill $MAINPIDRestartSec=always [Install]WantedBy=multi-user.target Code12systemctl start aria2.service #启动服务systemctl enable aria2.service #开机自启 谷歌浏览器安装Aria2 manager扩展，自动接管下载到aria2 Aria2 manager连接配置（单击浏览器扩展）： Aria2 manager自动接管设置（扩展图标右键设置）： sublime3破解修改hosts文件windows ： C:\\Windows\\System32\\drivers\\etc\\hosts linux ：/etc/hosts Code123456789127.0.0.1 www.sublimetext.com127.0.0.1 sublimetext.com127.0.0.1 sublimehq.com127.0.0.1 license.sublimehq.com127.0.0.1 45.55.255.55127.0.0.1 45.55.41.2230.0.0.0 license.sublimehq.com0.0.0.0 45.55.255.550.0.0.0 45.55.41.223 注册码目前版本3211,20200307亲测成功 Code12345678910111213----- BEGIN LICENSE -----Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864------ END LICENSE ------​ 神舟k580s i7修复大黄蜂驱动通过manjaro设置中心安装大黄蜂驱动之后,检测大黄蜂启动失败 optirun glxgears -info报错 Code12[ 742.455237] [ERROR]You&apos;ve no permission to communicate with the Bumblebee daemon. Try adding yourself to the &apos;bumblebee&apos; group[ 742.455303] [ERROR]Could not connect to bumblebee daemon - is it running? 修复方案: Code1gpasswd -a chen bumblebee #把当前用户加入大黄蜂用户组,chen是当前用户 执行systemctl status bumblebeed继续报错 Code12Could not enable discrete graphics cardCould not open /proc/acpi/bbswitch: No such file or directory 修复: Code12sudo modprobe bbswitchsystemctl restart bumblebeed 执行systemctl status bumblebeed 报错: Code1Failed to assign any connected display devices to X screen 0 修复方案: Code1sudo gedit /etc/bumblebee/xorg.conf.nvidia #Option &quot;ConnectedMonitor&quot; &quot;DFP&quot;修改为Option &quot;ConnectedMonitor&quot; &quot;CRT&quot; Code1systemctl restart bumblebeed 执行systemctl status bumblebeed无报错信息 参考文档: http://ivo-wang.github.io/2018/06/23/archlinux%E5%A4%A7%E9%BB%84%E8%9C%82/ https://forum.manjaro.org/t/solved-bumblebee-no-permission-to-connect-to-the-bumblebee-daemon-could-not-connect-to-the-bumblebee-daemon/57416 https://wiki.archlinux.org/index.php/Bumblebee_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Xlib:extension%22GLX%22_missing_on_display_%22:0.0%22 参考文档中安装方法(待尝试): Code12345678910111213141516171819202122232425sudo pacman -S bumblebee mesa nvidia xf86-video-intel# 必装的sudo pacman -S mesa-demos# 3dsudo pacman -S nvidia-settings# nvidia设置，没啥用sudo pacman -S bbswitch# 大黄蜂的自动电源管理sudo pacman -S xorg-xrandr# xrandr,用来查看分辨率用sudo gpasswd -a &lt;user&gt; bumblebee# 安装,并添加用户到bumblebee用户组systemctl enable bumblebeed.service# 启用bumblebee，然后重启继续# bumblebee的作用是禁用nvidia独立显卡,# 需要使用独显时，使用”optirun 程序名“开启nvidia来运行需要加速的程序。optirun glxspheres64optirun glxspheres32# 运行glxspheres64测试程序，optirun用于使用独显运行程序# 测试(x64或x32)，会打开一个动画窗口sudo pacman -S bbswitch# Bumblebee会自动检测bbswitch，可以自动关闭N卡lspci | grep VGA# 查看独显示状态，(rev ff)表示关闭，否则为打开状态# 运行glxspheres64时，则不为(rev ff) conky配置安装conky sh12yay -S conkysudo pacman -S conky-manager sh1gedit ~/.conkyrc #修改配置文件，最下方enp8s0替换为自己n网卡名字，ip ddr 命令可以查看网卡名称 sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869use_spacer rightuse_xft yesfont Microsoft YaHei:size=8xftfont Microsoft YaHei:size=8override_utf8_locale yesupdate_interval 1.0own_window yesown_window_type desktopown_window_transparent yes#own_window_hints undecorated,below,sticky,skip_taskbar,skip_pagerown_window_argb_visual yesown_window_argb_value 120double_buffer yesminimum_size 360 6maximum_width 400draw_shades yesdraw_outline nodraw_borders nodraw_graph_borders nodefault_color ffffffdefault_shade_color 000000default_outline_color 000000alignment top_rightgap_x 5gap_y 35cpu_avg_samples 2uppercase no # set to yes if you want all text to be in uppercaseTEXT$&#123;font Microsoft YaHei:style=Bold:pixelsize=20&#125;$&#123;alignc&#125;$&#123;time %H:%M:%S&#125;$&#123;font Microsoft YaHei:pixelsize=14&#125;$&#123;alignc&#125;$&#123;time %b%d日星期%a&#125;$&#123;alignc&#125;$&#123;color #ffa200&#125;$&#123;hr 2&#125;$&#123;font Microsoft YaHei:pixelsize=12&#125;$&#123;color #00ffcf&#125;主机名:$&#123;color #00ffcf&#125; $alignr$nodename$&#123;color #00ffcf&#125;内核: $&#123;color #00ffcf&#125;$alignr$kernel$&#123;color #00ffcf&#125;已运行时间: $&#123;color #00ffcf&#125;$alignr$uptime$&#123;color #ffd700&#125;$&#123;stippled_hr 1&#125;$&#123;font Microsoft YaHei:pixelsize=12&#125;$&#123;color #00ff1e&#125;CPU 1: $&#123;cpu cpu0&#125;% $alignr$acpitemp°C(T)$&#123;color #dcff82&#125;$&#123;cpubar 8 cpu0&#125;$&#123;color #00ff1e&#125;CPU 2: $&#123;cpu cpu1&#125;%$&#123;color #dcff82&#125;$&#123;cpubar 8 cpu1&#125;$&#123;color #00ff1e&#125;CPU 3: $&#123;cpu cpu2&#125;%$&#123;color #dcff82&#125;$&#123;cpubar 8 cpu2&#125;$&#123;color #00ff1e&#125;CPU 4: $&#123;cpu cpu3&#125;%$&#123;color #dcff82&#125;$&#123;cpubar 8 cpu3&#125;$&#123;color #00ff1e&#125;CPU占用:$alignr CPU% PID$&#123;color #ddaa00&#125; $&#123;top name 1&#125;$alignr$&#123;top cpu 1&#125; $&#123;top pid 1&#125;$&#123;color lightgrey&#125; $&#123;top name 2&#125;$alignr$&#123;top cpu 2&#125; $&#123;top pid 2&#125;$&#123;color lightgrey&#125; $&#123;top name 3&#125;$alignr$&#123;top cpu 3&#125; $&#123;top pid 3&#125;$&#123;color #ffd700&#125;$&#123;stippled_hr 1&#125;$color$&#123;font Microsoft YaHei:pixelsize=12&#125;$&#123;color #00ff1e&#125;SAM: $mem $alignr$&#123;color #db7093&#125;$memperc%$&#123;color #78af78&#125;$&#123;membar 8&#125;$&#123;color #00ff1e&#125;内存占用: $alignr MEM%$&#123;color #ddaa00&#125; $&#123;top_mem name 1&#125;$alignr $&#123;top_mem mem 1&#125;$&#123;color lightgrey&#125; $&#123;top_mem name 2&#125;$alignr $&#123;top_mem mem 2&#125;$&#123;color lightgrey&#125; $&#123;top_mem name 3&#125;$alignr $&#123;top_mem mem 3&#125;$&#123;color #ffd700&#125;$&#123;stippled_hr 1&#125;$color$&#123;font Microsoft YaHei:pixelsize=12&#125;$&#123;color #00ff1e&#125;硬盘读取速度:$&#123;alignr&#125;$&#123;diskio_read&#125;$&#123;color #00ff1e&#125;硬盘写入速度:$&#123;alignr&#125;$&#123;diskio_write&#125;$&#123;font Microsoft YaHei:pixelsize=12&#125;$&#123;color #00ff1e&#125;/ 分区: $&#123;color&#125;$&#123;alignr&#125;$&#123;fs_used /&#125;/ $&#123;fs_size /&#125;$&#123;color #78af78&#125;$&#123;fs_bar 8 /&#125;$&#123;color #00ff1e&#125;/boot 分区: $&#123;color&#125;$&#123;alignr&#125;$&#123;fs_used /boot&#125;/ $&#123;fs_size /boot&#125;$&#123;color #78af78&#125;$&#123;fs_bar 8 /boot&#125;$&#123;color #00ff1e&#125;/home 分区: $&#123;color&#125;$&#123;alignr&#125;$&#123;fs_used /home&#125;/ $&#123;fs_size /home&#125;$&#123;color #78af78&#125;$&#123;fs_bar 8 /home&#125;$&#123;color #ffd700&#125;$&#123;stippled_hr 1&#125;$color$&#123;font Microsoft YaHei:pixelsize=12&#125;$&#123;color #00ff1e&#125;网络 $alignr $&#123;color #00ff1e&#125;IP地址: $&#123;color DDAA00&#125;$&#123;addr enp8s0&#125;$&#123;voffset 1&#125;$&#123;color #98c2c7&#125; 上传: $&#123;color #db7093&#125;$&#123;upspeed enp8s0&#125;/s $&#123;alignr&#125;$&#123;color #98c2c7&#125;总共: $&#123;color #db7093&#125;$&#123;totalup enp8s0&#125;$&#123;voffset 1&#125;$&#123;color #98c2c7&#125; 下载: $&#123;color #ddaa00&#125;$&#123;downspeed enp8s0&#125;/s $&#123;alignr&#125;$&#123;color #98c2c7&#125;总共: $&#123;color #ddaa00&#125;$&#123;totaldown enp8s0&#125;$&#123;color #ffa200&#125;$&#123;hr 2&#125; 效果图：","categories":[{"name":"manjaro","slug":"manjaro","permalink":"https://chinantfy.gitee.io/categories/manjaro/"}],"tags":[]}]}